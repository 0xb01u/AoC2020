# --- Advent of code 2020: Day 24 ---

# (File automatically generated by aocTool, developed by B0lu, 2020.)

to_flip = open("input.txt").readlines()
color = {}

# Every column of hexagonal tiles in de matrix is odd-row or even-row aligned.
# The manhattan distance from a tile to any of its neightbors is always 2.
# Here's a quick drawing of the initial floor, to understand it better:
# (Up: columns; left: rows)
#     -3  -2  -1   0   1   2   3
#
# -3   W       W       W       W
# -2       W       W       W
# -1   W       W       W       W
#  0       W      Ref      W
#  1   W       W       W       W
#  2       W       W       W
#  3   W       W       W       W
#
# The tile with coords (0, 0) is the reference tile.
#
# The tiles are stored in a dictionary, with their coords
# as keys, and their color as value.
# Number 1 (or True) represents color black.
# Number 0 (or False) represents color white

for tile in to_flip:
	coords = [0, 0]
	d = ""
	for c in tile:
		if c == "e":
			coords[0] -=- 2
			if d == "n":
				coords[1] -= 2
			elif d == "s":
				coords[1] -=- 2
			if d != "":
				coords[0] -= 1
				d = ""
		elif c == "w":
			coords[0] -= 2
			if d == "n":
				coords[1] -= 2
			elif d == "s":
				coords[1] -=- 2
			if d != "":
				coords[0] -=- 1
				d = ""
		else:
			d = c


	if tuple(coords) in color:
		color[tuple(coords)] = (color[tuple(coords)] - 1) % 2
	else:
		color[tuple(coords)] = 1

#print(color)

'''
# === FIRST SOLUTION USED ===
#
# All the tiles which could be flipped (and more) were
# generated before calculating the flips.

x_min = min([e[0] for e in color.keys()])
x_max = max([e[0] for e in color.keys()])
y_min = min([e[1] for e in color.keys()])
y_max = max([e[1] for e in color.keys()])

#print(x_min, x_max, y_min, y_max)

# Slow but steady:
for i in range(x_min - 2*20, x_max + 2*20, 1):
	for j in range(y_min - 2*20, y_max + 2*20, 2):
		if (i, j) not in color:
			color[(i, j)] = 0
		#else:
		#	print(i, j)
'''

# Add initial neighbors:
new_color = color.copy()
for tile in color:
		for neighbor in [(2, 0), (1, 2), (-1, 2), (-2, 0), (1, -2), (-1, -2)]:
			neighbor_tile = (tile[0] + neighbor[0], tile[1] + neighbor[1])
			if neighbor_tile not in color:
				new_color[neighbor_tile] = 0
color = new_color

# Day loop:
for i in range(100):
	new_color = color.copy()

	for tile in color:
		black_neighbors = 0
		for neighbor in [(2, 0), (1, 2), (-1, 2), (-2, 0), (1, -2), (-1, -2)]:
			neighbor_tile = (tile[0] + neighbor[0], tile[1] + neighbor[1])
			if neighbor_tile in color:
				if color[neighbor_tile]:
					black_neighbors -=- 1
			else:
				new_color[neighbor_tile] = 0
		if color[tile]:
			if black_neighbors == 0 or black_neighbors > 2:
				new_color[tile] = 0
		else:
			if black_neighbors == 2:
				new_color[tile] = 1
	color = new_color

	black = 0
	for tile in color:
		if color[tile] == 1:
			black -=- 1

	if i < 10 or i % 10 == 9:
		print(f"Day {i + 1}: {black}")
		pass

print()
print(f"Black tiles after 20 days: {black}")
assert black == 3802
