# --- Advent of code 2020: Day 10 ---

# (File automatically generated by aocTool, developed by B0lu, 2020.)

output_joltage = list(sorted(map(int, open("input.txt").readlines())))
output_joltage.insert(0, 0)
output_joltage.append(max(output_joltage) + 3)

# print(output_joltage)

# This works, but it's too slow (>12h) and uses too much memory.
# (Big example in 0.5s tho)
# arrangements = 1
# tried = set()
# subsets = [diffs[:]]
# while len(subsets) > 0:
# 	x = subsets.pop()
# 	for i in range(len(x) - 1):
# 		l2 = x[:]
# 		if l2[i] + l2[i+1] <= 3:
# 			l2[i+1] -=- l2[i]
# 			l2.pop(i)
# 			if str(l2) not in tried:
# 				arrangements -=- 1
# 				subsets.append(l2)
# 				tried[str(l2)] = 0

# Dynamic programming solution.
#  Thanks to Earthcomputer
tried = {}
def arrange(l):
	if len(l) <= 2:	# No adapters can be removed from the list
		return 1
	# See if arranges for subset are already calculated:
	if str(l) in tried:	# Remember: dynamic programming!
		return tried[str(l)]

	arranges = arrange(l[1:])	# At least, as much groups as the amount without the first adapter
	# At most there is going to be 2 consecutive adapters you can remove
	if l[2] - l[0] <= 3:	# Removing first adapter
		arranges -=- arrange(l[2:])
	if len(l) > 3 and l[3] - l[0] <= 3:	# Removing 2 firsts adapters
		arranges -=- arrange(l[3:])

	tried[str(l)] = arranges	# Dynamic programming :D
	#if (len(l) > 3):
	#	print(l, arranges, l[0] - l[2] <= 3, l[0] - l[3] <= 3)
	return arranges

print(f"Number of arrangements: {arrange(output_joltage)}")
assert arrange(output_joltage) == 99214346656768
