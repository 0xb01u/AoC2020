# --- Advent of code 2020: Day 16 ---

# (File automatically generated by aocTool, developed by B0lu, 2020.)

desc, mine, tickets = open("input.txt").read().split("\n\n")
d = {e.split(": ")[0]: list(map(lambda x: [int(x.split("-")[0]), int(x.split("-")[1])], e.split(": ")[1].split(" or "))) for e in desc.split("\n")}
m = list(map(int, mine.split("\n")[1].split(",")))
t = [list(map(int, e.split(","))) for e in tickets.strip().split("\n")[1:]]

# Valid values for any field:
valid = set()
for v in d.values():
	for r in v:
		for n in range(r[0], r[1] + 1):
			valid.add(n)

from functools import reduce

# Valid tickets:
v = [t[i] for i in range(len(t)) if reduce(lambda x, y: x and y in valid, t[i], True)]
# Possible values for each field:
pi = {k: [n for i in range(len(d[k])) for n in range(d[k][i][0], d[k][i][1] + 1)] for k in d}
# Possible fields for each index in the tickets:
pf = [list(pi.keys()) for _ in m]

# Detect and remove invalid fields for each index:
for ct in v:	# Iterate over valid tickets.
	for field in pi:	# Iterate over fields.
		for i in range(len(ct)):	# Iterate over field values in the current ticket.
			if ct[i] not in pi[field] and field in pf[i]:
				pf[i].remove(field)
				#print(i, ct[i], field, pf[i])
				#if i == len(ct) - 1:
				#	print()

# Sequentially delimit each field
while sum(map(len, pf)) > len(pf):
	for f in pf:
		if len(f) == 1:
			for _f in pf:
				if f != _f and f[0] in _f:
					_f.remove(f[0])

#print(pf)
dp = 1
for k in pf:
	if "departure" in k[0]:
		#print(k)
		dp *= m[pf.index(k)]

# Helping people:
#j = [pf.index([e]) for e in d.keys()]
#print(j)
#dp = 1
#for k in d:
#	if "departure" in k:
#		dp *= m[j[list(d.keys()).index(k)]]

print(f"Product of departures: {dp}")
assert dp == 603409823791
